import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.Collections;

/**
 * 'EventList'  this class is used to manage an ArrayList of events
 * class is used exclusively by the 'Menu' class
 */
public class EventList {
	ArrayList<Event> events;
	
	/**
	 * 'EventList'  is a constructore which initialized the ArrayList
	 * - take no parameters
	 */
	public EventList() {
		events = new ArrayList<Event>();
	}
	
	/**
	 * 'addEvent' this function is used to add an event to the ArrayList
	 * @param event - event is created by user or during initial event loading
	 * - returns nothing
	 */
	public void addEvent(Event event) {
		events.add(event);
	}
	
	/**
	 * 'removeEvent' this function is called in order to remove an event from the ArrayList
	 * @param event - event object was found and passed by menu function
	 * - returns nothing
	 */
	public void removeEvent(Event event) {
		events.remove(event);
	}
	
	/**
	 * 'print'  prints all event by calling each toString function
	 * - takes no arguments
	 * - returns nothing
	 */
	public void print() {
		for(Event e : events) {
			System.out.println(e.toString());
		}
	}
	
	/**
	 * 'deleteSingleEvent' this function is called in order to identify and delete a specific event by user input
	 * @param title - a 'string' of the title of an event the user wants to delete
	 * @param date - a LocalDate generated by user input
	 * - returns nothing
	 */
	public void deleteSingleEvent(String title, LocalDate date) {
		int index = 0;
		for(Event e : events) {
			if(e.getType().equals("single") && 
			  e.getTitle().equals(title) &&
			  e.getStartDate().equals(date)) {
				events.remove(index);
				System.out.println("\nResult: Event Deleted.");
				return;
			}
			index++;
		}
		System.out.println("No Event Deleted: event not found");
		return;
	}
	
	/**
	 * 'deleteAllSingleEventsForASpecificdate' used to delete all single events for a specific date
	 * @param date - a LocalDate object used to identify the date to be cleared
	 * - returns nothing
	 */
	public void deleteAllSingleEventsForASpecificDate(LocalDate date) {
		int wasDeleted = 0;
		ArrayList<Event> toBeDeleted = new ArrayList<>();
		for(Event e : events) {
			if(e.getType().equals("single") && 
			  e.getStartDate().equals(date)) {
				toBeDeleted.add(e);
				wasDeleted++;
			}
		}
		for(Event i : toBeDeleted) {
			events.remove(i);
		}
		if(wasDeleted > 0) {
			System.out.println("\nResult: " + wasDeleted + " event/s was/were deleted.");
			return;
		}
		System.out.println("No Event Deleted: events not found");
		return;
	}
	
	/**
	 * 'deleteRepeatingEvent'  this function is called to delete a 'RepeatingEvent' from the events ArrayList
	 * @param title - a user entered String used to find the repeating event object
	 * - returns nothing
	 */
	public void deleteRepeatingEvents(String title) {
		int index = 0;
		for(Event e : events) {
			if(e.getType().equals("repeat") && 
			  e.getTitle().equals(title)) {
				events.remove(index);
				System.out.println("\nResult: Repeating Event Deleted.");
				return;
			}
			index++;
		}
		System.out.println("No Event Deleted: event not found");
		return;
	}
	
	/**
	 * 'getOrderedDays'  this function is used in order to find all events on a specific day
	 * @param selectedDate - a LocalDate object which provides the date for the desired events
	 * @return ArrayList - this array list is sorted chronologically (earliest first) of all events on a specific day
	 */
	public ArrayList<Event> getOrderedDays(LocalDate selectedDate){
		ArrayList<Event> daysEvents = new ArrayList<Event>();
		for(Event e : events) {
			//if single event
			if(e.getType().equals("single") && e.getStartDate().equals(selectedDate)) {
				daysEvents.add(e);
			} 
			//if repeating event
			else if (e.getType().equals("repeat") &&
					 e.getEndDate().isAfter(selectedDate) &&
					 e.getStartDate().isBefore(selectedDate)) {
				ArrayList<DayOfWeek> days = new ArrayList<DayOfWeek>(e.daysOfWeek());
				for(DayOfWeek d : days) {
					if(d.getValue() == selectedDate.getDayOfWeek().getValue() ) {
						daysEvents.add(e);
					}
				}
			}
		}
		Collections.sort(daysEvents);
		return daysEvents;
	}
	
	/**
	 * 'checkEvents' this function is used to see if an event already exists which conflicts with desired time slot
	 * @param title - a String passed in case future developer wants to check for unique names
	 * @param date - a String passed to identify date of interest
	 * @param startingTime -  a String describing a time window we want to know if is available
	 * @param endingTime -  a String describing a time window we want to know if is available
	 * @return boolean - true if time slot is open, false if there is a time conflict
	 */
	public boolean checkEvents(String title, String date, String startingTime, String endingTime) {

		String[] times;
		// turn string date to new date
		times = date.split("[/]");
		LocalDate formattedDate = LocalDate.of(Integer.parseInt(times[2]),
									 Integer.parseInt(times[0]),
									 Integer.parseInt(times[1]));
		ArrayList<Event> potentialConflicts = getOrderedDays(formattedDate);
		//turn start and end time strings to localtime
		times = startingTime.split("[:]");
		LocalTime startTime = LocalTime.of(Integer.parseInt(times[0]),
				 				Integer.parseInt(times[1]));
		times = endingTime.split("[:]");
		LocalTime endTime = LocalTime.of(Integer.parseInt(times[0]),
				 				Integer.parseInt(times[1]));
		//check for conflicts
		for(Event e : potentialConflicts) {
			if(startTime.isAfter(e.start) && startTime.isBefore(e.end)) {
				return false;
			} else if(endTime.isAfter(e.start) && endTime.isBefore(e.end)) {
				return false;
			} else if(startTime.equals(e.start) || startTime.equals(e.end)) {
				return false;
			} else if(endTime.equals(e.start) || endTime.equals(e.end)) {
				return false;
			}
		}
		//create event
		events.add(new Event(title,startTime, endTime, formattedDate));
		return true;
	}
	
}
